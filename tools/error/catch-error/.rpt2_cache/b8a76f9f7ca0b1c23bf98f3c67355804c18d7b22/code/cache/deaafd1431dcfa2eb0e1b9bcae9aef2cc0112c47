{"code":"function handleError(ctx, errorClass, handler, error) {\r\n    let isMatch;\r\n    if (typeof error === 'function') {\r\n        isMatch = error();\r\n    }\r\n    else if (error === '*') {\r\n        isMatch = true;\r\n    }\r\n    else {\r\n        isMatch = error instanceof errorClass;\r\n    }\r\n    if (isMatch) {\r\n        const handlerType = typeof handler;\r\n        if (handlerType === 'function') {\r\n            return handler.call(ctx, error, ctx);\r\n        }\r\n        else if (handlerType === 'string') {\r\n            return ctx[handler](error);\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    throw error;\r\n}\r\n// decorator factory function\r\nexport default (errorClass, handler) => {\r\n    return (target, propertyKey, descriptor) => {\r\n        // save a reference to the original method\r\n        const originalMethod = descriptor.value;\r\n        // rewrite original method with custom wrapper\r\n        descriptor.value = function (...args) {\r\n            try {\r\n                const result = originalMethod.apply(this, args);\r\n                // check if method is asynchronous\r\n                if (result && typeof result.then === 'function' && typeof result.catch === 'function') {\r\n                    // return promise\r\n                    return result.catch((error) => {\r\n                        handleError(this, errorClass, handler, error);\r\n                    });\r\n                }\r\n                // return actual result\r\n                return result;\r\n            }\r\n            catch (error) {\r\n                handleError(this, errorClass, handler, error);\r\n            }\r\n        };\r\n        return descriptor;\r\n    };\r\n};\r\n","dts":{"name":"D:/Project/xfe-m-components/tools/error/catch-error/index.d.ts","text":"declare type HandlerFunction = (error: any, ctx: any) => void;\r\ndeclare const _default: (errorClass: any, handler: HandlerFunction) => any;\r\nexport default _default;\r\n"}}
